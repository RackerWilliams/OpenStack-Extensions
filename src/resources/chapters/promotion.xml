<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book [
<!-- Some useful entities borrowed from HTML -->
<!ENTITY ndash  "&#x2013;">
<!ENTITY mdash  "&#x2014;">
<!ENTITY hellip "&#x2026;">

<!-- Useful for describing APIs -->
<!ENTITY GET    '<command xmlns="http://docbook.org/ns/docbook">GET</command>'>
<!ENTITY PUT    '<command xmlns="http://docbook.org/ns/docbook">PUT</command>'>
<!ENTITY POST   '<command xmlns="http://docbook.org/ns/docbook">POST</command>'>
<!ENTITY DELETE '<command xmlns="http://docbook.org/ns/docbook">DELETE</command>'>
]>        

<chapter security="writer-only"
    xml:id="Promotion"
    xmlns="http://docbook.org/ns/docbook"
    xmlns:xi="http://www.w3.org/2001/XInclude"
    xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0">

    <title>Extension Governance and Promotion</title>
    <section>
        <title>Specification Governance</title>
        <para> OpenStack's existing structure adequately addresses governance of API extensions
            and features. For each service, the team lead handles concerns about functionality
            and the service's Architecture Review Board approves changes and resolves conflicts;
            the OpenStack Governance board provides oversight to maintain consistency and
            prevent conflicts among services.</para>
        <para>
            When OpenStack approves an extension, the extension's prefix is changed so that rather than identifying a specific vendor it identifies OpenStack as its source.
            For example, if the <code>RAX-PIE</code> extension were to be approved by OpenStack, the approved version would be known as <code>OS-PIE</code>.
            While the <code>OS-</code> prefix indicates approval by OpenStack,
            such approval does not necessarily imply that the extension is being considered for inclusion in a future revision of the API's core specification.
            A niche extension that offers highly useful functionality can gain OpenStack approval.
            Such an extension may never become a feature of the core API, but the extension can become one that is so frequently implemented that clients can rely on it in most cases.
        </para>
    </section>
    <section>
        <title>Promotion Path</title>
        <para> 
            The simplest promotion path for an extension is from a single vendor to OpenStack
            approval to implementation as a core API feature. 
        </para>
        <para> Some extensions may be developed cooperatively by more than one vendor; these are
            known as Multi-Vendor extensions and are identified by the <code>MLTI</code> prefix.
            Alternatively, an extension may begin with a single vendor but become a Multi-Vendor
            extension at some point in its life. In either of these cases, the extension follows
            same promotion path from Multi-Vendor status to OpenStack approval to implementation
            as a core API feature. </para>
        <para>
            This multi-step promotion path allows competing extensions to coexist and makes it possible to experiment with new features before deciding whether to incorporate them into the API standard.
            It also means that API specifications are written bottom-up rather than top-down, so that implementations determine new features and the API is not designed in a vacuum. 
        </para>
        <figure xml:id="promotion">
            <title>An API extension can become a core feature of the API if approved by OpenStack.</title>
            <mediaobject>
                <imageobject role="fo">
                    <imagedata scale="80" fileref="../figures/apix-promotion.svg" format="SVG" align="center"/>
                </imageobject>
                <imageobject role="html">
                    <imagedata fileref="figures/apix-promotion.png" format="PNG" align="center"/>
                </imageobject>
            </mediaobject>
        </figure>
        <para>
            Some extensions should never be promoted to core features.
            This can be because the extension implements niche functionality that doesn't make sense in the core API,
            or because it implements functionality that can't be used within the core API since it would prevent a particular backend from implementing the full set of core features.
        </para>
        <para>
            For example, the ability to dynamically change the port number for a load balancer might be useful as an extension but problematic in the core API.
            If most but not all load balancers could support this feature, the extension must not be promoted into the core API.
            Instead, providing the feature via an API extension makes it available to customers who would like to use it but prevents it from creating problems for those who cannot use it.
        </para>
    </section>
</chapter>
