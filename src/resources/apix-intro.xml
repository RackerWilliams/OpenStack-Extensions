<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book [
        <!-- Some useful entities borrowed from HTML -->
        <!ENTITY ndash  "&#x2013;">
        <!ENTITY mdash  "&#x2014;">
        <!ENTITY hellip "&#x2026;">

        <!-- Useful for describing APIs -->
        <!ENTITY GET    '<command xmlns="http://docbook.org/ns/docbook">GET</command>'>
        <!ENTITY PUT    '<command xmlns="http://docbook.org/ns/docbook">PUT</command>'>
        <!ENTITY POST   '<command xmlns="http://docbook.org/ns/docbook">POST</command>'>
        <!ENTITY DELETE '<command xmlns="http://docbook.org/ns/docbook">DELETE</command>'>

        <!ENTITY CHECK  '<inlinemediaobject xmlns="http://docbook.org/ns/docbook">
                 <imageobject>
                  <imagedata fileref="img/Check_mark_23x20_02.svg"
                             format="SVG" scale="60"/>
                </imageobject>
              </inlinemediaobject>'>

        <!ENTITY ARROW  '<inlinemediaobject xmlns="http://docbook.org/ns/docbook">
                 <imageobject>
                  <imagedata fileref="img/Arrow_east.svg"
                             format="SVG" scale="60"/>
                </imageobject>
              </inlinemediaobject>'>
]>
<book xmlns="http://docbook.org/ns/docbook"
      xmlns:xlink="http://www.w3.org/1999/xlink"
      xmlns:xi="http://www.w3.org/2001/XInclude"
      xmlns:svg="http://www.w3.org/2000/svg"
      xmlns:m="http://www.w3.org/1998/Math/MathML"
      xmlns:html="http://www.w3.org/1999/xhtml"
      xmlns:db="http://docbook.org/ns/docbook"
      version="5.0" status="draft">
    <title>Cloud API Extensions Overview</title>
    <info>
        <author>
            <personname>
                <firstname>Jorge L.</firstname>
                <surname>Williams</surname>
            </personname>
            <affiliation>
                <orgname>OpenStack</orgname>
            </affiliation>
        </author>
        <copyright>
            <year>2010</year>
            <year>2011</year>
            <holder>OpenStack</holder>
        </copyright>
        <releaseinfo>PROPOSAL</releaseinfo>
        <productname>Cloud API Extensions</productname>
        <pubdate>2011-05-13</pubdate>
        <legalnotice role="apache2">
            <annotation>
                <remark>Copyright details are filled in by the template.</remark>
            </annotation>
        </legalnotice>
        <abstract>
            <para>This document provides an overview of the OpenStack cloud API extensions
                mechanism. </para>
        </abstract>
    </info>
    <chapter>
        <title>Overview</title>
        <para> Cloud API extensions make it possible to add functionality to Cloud APIs without
            modifying the core of the API itself. </para>
        <section>
            <title>Document Change History</title>
            <informaltable rules='all'>
                <thead>
                        <tr>
                            <td align="center" colspan="1">Revision Date</td>
                            <td align="center" colspan="4">Summary of Changes</td>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td colspan="1" align="center">May 13, 2011</td>
                            <td colspan="4">
                                <itemizedlist spacing="compact">
                                    <listitem>
                                        <para> Initial draft. </para>
                                    </listitem>
                                </itemizedlist>
                            </td>
                        </tr>
                    </tbody>
            </informaltable>
        </section>
    </chapter>
    <chapter>
        <title>Problems with Developing OpenStack Services</title>
        <para>
            Efforts to develop OpenStack cloud services face some of the same challenges as other open source software projects.
            The need for innovation can compete with the need for stability. 
            The goal of supporting a wide variety of configurations can compete with the reality that some features are incompatible with others.
            Ongoing decentralized development of services by independent software developers can mean that administration of services is complex and confusing to customers.
        </para>
        <section>
            <title>Standardization versus Innovation and Differentiation</title>
            <para>API extensions can create compatibility between two seemingly-conflicting
                OpenStack goals, making it possible to support stable and generalizable open
                standards while also supporting innovation and experimentation.</para>
            <para>
                Defining standard APIs is good for OpenStack and good for OpenStack customers. 
                Standardization encourages others to implement OpenStack APIs. 
                Stability is a prerequisite for standardization and widespread adoption, since code that is in constant flux is difficult to implement and difficult to develop against.
                At the same time, standards must be general, since niche functionality may make it impossible for some customers to adopt some standards.
                The more general and stable the API, the more likely it will be widely adopted.
            </para>
            <para>
                While standardization is essential, it must coexist with innovation.
                We must be able to add features that differentiate one implementation from other implementations, and we must be able to do that without breaking our clients and without going through an approval process.
                Everyone must be able to make changes to the API.
                The possibility of modification and customization encourages customers with a variety of needs to adopt OpenStack APIs; changes made to support one customer's needs can be beneficial to all. 
                Developers should feel free to experiment and develop new features without worrying about the implications to the API as a standard.
            </para>
            <para>
                This combination of stability and flexibility will allow OpenStack to create a ubiquitous cloud technology.
            </para>
        </section>
        <section>
            <title>Pluggability</title>
            <para> OpenStack services are pluggable, so that one OpenStack service can support many
                backends. For a compute service, backends can be hypervisors; for a network service,
                backends can be network switches. A backend can be implemented as a driver,
                containing a set of shared capabilities widely applicable to all deployments. Each
                backend may also contain special features and niche functionality. The goal is to
                provide access to special features while abstracting away the details of the
                backend. In the example illustrated below, one load balancing service connects to
                backends for Zeus, Pound, and HAProxy, with each backend providing unique
                functionality.</para>
            <figure xml:id="manyBackends">
                <title>One service can reach many backends.</title>
                <mediaobject>
                    <imageobject>
                        <imagedata scale="100" fileref="figures/apix-1service-manyBackends.svg" format="SVG" align="center"/>
                    </imageobject>
                </mediaobject>
            </figure>
            </section>
        <section>
            <title>Open Source</title>
            <para>
                On of the challenges for OpenStack customers is that OpenStack services are open source, so all developers can make changes to the code. 
                For APIs provided by OpenStack as well as by multiple vendors, a customer can face great difficulty in choosing among and managing versions of the API. 
                For example, a compute service may be reachable via an OpenStack stock API, a Rackspace-supported API, and modifications by other vendors and individuals; 
                all these implementations of the "same" API may also exist in multiple versions.
            </para>
            <para>
                Customers must be able to rely on a core set of API functionality.
                Different customers may implement different options, but it must be possible for everyone to mean the same thing by the same label.
                We must also be able to ensure compatibiity among different versions; this works best if we have consistent ways of identifying and describing versions.
            </para>
        </section>
    </chapter>
    <chapter>
        <title>A Solution: API Extensions</title>
        <para> 
            The problems faced by OpenStack are not new. 
        </para>
            <para>
                In the 1990s, OpenGL faced the challenge of defining an open graphics library that would be considered a standard specification, 
                would allow vendors to differentiate their products by adding special features.
                An Architecture Review Board (ARB) would propose and approve specification changes, make new releases, and ensure conformance testing.
            </para>
            <para>
                OpenGL's solution was to allow extensions in the specification. 
                Vendors could define special features as extensions, but the core of the specification remained under the control of the ARB.
            </para>
            <para>
                This was a very successful strategy, allowing the core OpenGL API to become a general, uncluttered, and accepted standard.
                More than 500 extensions have been defined in OpenGL's lifetime. 
                <itemizedlist spacing="compact">
                    <listitem>
                        <para>The best extensions become standard features.</para>
                    </listitem>
                    <listitem>
                        <para>Unsuccessful extensions are abandoned prior to any attempt to incorporate them into the API.</para>
                    </listitem>
                    <listitem>
                        <para>When multiple extensions are developed to support the same feature, all the variations are offered, allowing the best one to win.</para>
                    </listitem>
                    <listitem>
                        <para>Key innovations developed via the extension process include vertex and fragment shaders.</para>
                    </listitem>
                    <listitem>
                        <para>Major vendors participating in the extension process include NVidia, ATI, Apple, IBM, and Intel.</para>
                    </listitem>
                </itemizedlist>
            </para>
        <section>
            <title>Defining Extensions</title>
            <para>
                Extensions add capability to an API beyond those defined in the API's specification.
            </para>
            <para>
                An API specification must be written to allow for extensibility.
                Flexibility in the specification contract allows for new data elements, actions, states, headers, parameters, and resource types.
                The core API specification defines the extension mechanism; extensions themselves are not part of the core.
            </para>
            <para>
                Implementors are only required to implement the core API.
                They must implement the core API completely, so clients can rely upon a minimal level of functionality.
            </para>
            <para>
                Extensions can follow a promotion path, at the end of which an extension may become part of a future version of the core API.
                While promotion is possible, it is not inevitable: niche extensions are unlikely to be promoted to the core.
            </para>
        </section>
        <section>
            <title>Extensions versus Versions</title>
            <para> With API extensions in place, API implementations can differ from each other in
                terms of both their versions and their extensions. Extensions can apply to a variety
                of backends, such as many hypervisors and many load balancers. Accurately describing
                an API implementation requires awareness of its versions and extensions as sources
                of variation. </para>
            <table frame="all">
                <title>Versions and Extensions Differ in Specific Ways</title>
                <tgroup cols="2">
                    <colspec colname="c1" colnum="1" colwidth="1.0*"/>
                    <colspec colname="c2" colnum="2" colwidth="1.0*"/>
                    <thead>
                        <row>
                            <entry>Versions</entry>
                            <entry>Extensions</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>
                                <para><emphasis role="bold">Centralized:</emphasis> Versions are
                                    maintained by the entity that controls the API Spec: The
                                    OpenStack Architecture Board. Only the ARB can create a new
                                    version, only the ARB defines what OpenStack Compute 1.1
                                    means.</para>
                            </entry>
                            <entry>
                                <para><emphasis role="bold">Decentralized:</emphasis> Extensions are
                                    maintained by third parties: Rackspace, OpenStack developers,
                                    etc. Anyone can create an Extension.</para>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <para><emphasis role="bold">Core:</emphasis> Versions support core
                                    functionality.</para>
                            </entry>
                            <entry>
                                <para><emphasis role="bold">Niche:</emphasis> Extensions provide
                                    specialized functionality.</para>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <para><emphasis role="bold">Rare:</emphasis> Versions provide a
                                    stable platform on which to develop.</para>
                            </entry>
                            <entry>
                                <para><emphasis role="bold">Frequent:</emphasis> Extensions bring
                                    new features to the market quickly and in a compatible
                                    manner.</para>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <para><emphasis role="bold">Queryable: </emphasis>You can
                                    programmatically tell what versions are available by doing a &GET;
                                    on the base URL (<code>/</code>) of the API endpoint.</para>
                            </entry>
                            <entry>
                                <para><emphasis role="bold">Queryable:</emphasis> You can
                                    programmatically tell what extensions are available by doing a
                                    &GET; on the API's extensions resource
                                        (<code>/v1.1/extensions</code>).</para>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>

        </section>
        <section>
            <title>Extensions and Pluggability</title>
            <para> Each driver may expose functionality that a client may access via an extension.
                In the example illustrated below, the load balancing service API's core and
                extensions both provide functionality enabling the service to interact with its Zeus
                backend. </para>
            <figure xml:id="core-extensions">
                <title>One backend can be reached by both the core API and API extensions.</title>
                <mediaobject>
                    <imageobject>
                        <imagedata scale="100" fileref="figures/apix-1service-core-extensions-manybackends.svg" format="SVG" align="center"/>
                    </imageobject>
                </mediaobject>
            </figure>
        </section>
    </chapter>
    <chapter>
        <title>API Extensions and ReST</title>
              <para>
                Extensions can define:
                <itemizedlist spacing="compact">
                    <listitem>
                        <para>new elements</para>
                    </listitem>
                    <listitem>
                        <para>new attributes of existing elements</para>
                    </listitem>
                    <listitem>
                        <para>new data</para>
                    </listitem>
                    <listitem>
                        <para>new headers</para>
                    </listitem>
                    <listitem>
                        <para>new states</para>
                    </listitem>
                    <listitem>
                        <para>new resources</para>
                    </listitem>
                    <listitem>
                        <para>new parameters</para>
                    </listitem>
                    <listitem>
                        <para>new MIME types</para>
                    </listitem>
                    <listitem>
                        <para>new capabilities</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                New MIME types can provide support for Atom or plist representation.
            </para>
            <para>
                New capabilities can include the ability to edit an otherwise-uneditable attribute.
            </para>       
            <section>
                <title>Identifying Available Extensions</title>
            <para>
                Extensions are queryable. 
                For any service API, making a single call to <code>/extensions</code> returns information about what extensions are available and how to learn more about them. 
            </para>
            <para>
                Query <code>/extensions</code> to obtain basic information about an API's extensions, including their human-readable names and descriptions, links to documentation, and identification of each extension's alias, namespace, and vendor.
            </para>
            <example>
                <title>Extension Query: XML</title>
                <programlistingco>
                    <areaspec>
                        <area xml:id="query.human-readable.name" units="linecolumn" coords="4 45"/>
                        <area xml:id="query.human-readable.description" units="linecolumn" coords="14 9"/>
                        <area xml:id="query.docs" units="linecolumn" coords="11 80"/>
                        <area xml:id="query.identifiers" units="linecolumn" coords="7 9"/>
                        <area xml:id="query.vendor.namespace" units="linecolumn" coords="17 46"/>
                        <area xml:id="query.vendor.alias" units="linecolumn" coords="19 24"/>
                    </areaspec>
                    <programlisting language="xml">
<xi:include href="samples/apix-query.xml" parse="text"/>
                    </programlisting>
                </programlistingco>
            </example>
                <calloutlist>
                    <callout arearefs="query.human-readable.name">
                        <para>
                            The query returns the extension's human-readable name.
                        </para>
                    </callout>
                    <callout arearefs="query.human-readable.description">
                        <para>
                            The query returns the extension's human-readable description.
                        </para>
                    </callout>
                    <callout arearefs="query.docs">
                        <para>
                            The query returns links to documentation in multiple formats.
                        </para>
                    </callout>
                    <callout arearefs="query.identifiers">
                        <para>
                            The query uniquely identifies the extension as an alias within a namespace.
                        </para>
                    </callout>
                    <callout arearefs="query.vendor.namespace">
                        <para>
                            The query identifies the extension's vendor in the extension's namespace.
                        </para>
                    </callout>
                    <callout arearefs="query.vendor.alias">
                        <para>
                            The query identifies the extension's vendor in the extension's alias.
                        </para>
                    </callout>
                </calloutlist>
        </section>
        <section>
            <title>Identifying an Extension's Vendor</title>
            <para>
                An extension alias always contains a prefix that identifies the vendor. 
            </para>
                <table frame="all">
                    <title>Extension Alias Identifies Vendor</title>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.0*"/>
                        <colspec colname="c2" colnum="2" colwidth="2.39*"/>
                        <thead>
                            <row>
                                <entry>Prefix</entry>
                                <entry>Vendor</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><code>OS</code></entry>
                                <entry>OpenStack</entry>
                            </row>
                            <row>
                                <entry><code>MLTI</code></entry>
                                <entry>Multi-Vendor</entry>
                            </row>
                            <row>
                                <entry><code>RAX</code></entry>
                                <entry>Rackspace</entry>
                            </row>
                            <row>
                                <entry><code>NASA</code></entry>
                                <entry>NASA</entry>
                            </row>
                            <row>
                                <entry><code>CTX</code></entry>
                                <entry>Citrix</entry>
                            </row>
                            <row>
                                <entry>...</entry>
                                <entry>...</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            <para>
                In this example, the <code>RAX</code> prefix in the extension's alias identifies the extension's vendor as Rackspace:
            </para>
            <example>
                <title>Vendor ID in Alias Extension: XML</title>
                <programlisting language="xml">
<xi:include href="samples/apix-vendor.xml" parse="text"/>
                </programlisting>
            </example>
            <para>
                Each extension is associated with a namespace; because the namespace is named to identify a vendor, the extension's association with a namespace also identifies the extensions's vendor.
            </para>
            <table frame="all">
                <title>Namespace Identifies Vendor</title>
                <tgroup cols="2">
                    <colspec colname="c1" colnum="1" colwidth="1.0*"/>
                    <colspec colname="c2" colnum="2" colwidth="2.33*"/>
                    <thead>
                        <row>
                            <entry>Prefix</entry>
                            <entry>Vendor</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>
                                <para>
                                    <code>http://docs.openstack.com/ext/OS/</code>...
                                </para>
                            </entry>
                            <entry>OpenStack</entry>
                        </row>
                        <row>
                            <entry>
                                <para>
                                    <code>docs.rackspacecloud.com</code>...
                                </para>
                            </entry>
                            <entry>Rackspace</entry>
                        </row>
                        <row>
                            <entry>
                                <para>
                                    <code>http://docs.nasa.org</code>...
                                </para>
                            </entry>
                            <entry>NASA</entry>
                        </row>
                        <row>
                            <entry>
                                <para>
                                    <code>http://docs.citrix.com</code>...
                                </para>
                            </entry>
                            <entry>Citrix</entry>
                        </row>
                        <row>
                            <entry>...</entry>
                            <entry>...</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <para>
                Providing two ways of identifying each extension's vendor improves the likelihood that multiple extensions can coexist without creating conflicts.
                For this purpose, a namespace such as <code>http://docs.rackspacecloud.com/servers/api/ext/pie/v1.0</code> is most useful to XML media types; 
                an alias such as <code>RAX-PIE</code> is most useful to non-XML media types such as JSON, as well as in headers and parameters.
                Because extensions are likely to be implemented by middleware, conflicts are possible without a standardized approach to identifying each extension and its vendor.
            </para>
            <figure xml:id="shared">
                <title>Two extensions add a "shared" attribute; one overrides the other.</title>
                <mediaobject>
                    <imageobject>
                        <imagedata scale="100" fileref="figures/apix-2extensions-shared.svg" format="SVG" align="center"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <figure xml:id="filter">
                <title>Two extensions read a "filter" parameter; both are activated.</title>
                <mediaobject>
                    <imageobject>
                        <imagedata scale="100" fileref="figures/apix-2extensions-filter.svg" format="SVG" align="center"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <para>
                OpenStack should maintain a registry associating extension vendors with prefixes and namespaces. 
                Anyone should be able to register this identifying information for a vendor.
                The registration process should not require approval or coordination.
            </para>
        </section>
        <section>
            <title>Extending Data</title>
            <para>
                Extensions can be used to add data.
            </para>
            <para>
                In XML, attributes may be added to elements if they are in the extension namespace. 
                After the final element, elements can be added if "Unique Particle Attribution" is not violated.
            </para>
            <example>
                <title>Extending Data: XML</title>
                <programlisting language="xml">
<xi:include href="samples/apix-data.xml" parse="text"/>
                </programlisting>
            </example>
            <para>
                In JSON, the action name is the alias followed by a colon ":".
            </para>
            <example>
                <title>Extending Data: JSON</title>
                <programlisting language="javascript">
<xi:include href="samples/apix-data.json" parse="text"/>
                </programlisting>
            </example>
        </section>
        <section>
            <title>Extending Actions</title>
            <para>
                In XML, actions are defined by the extension namespace.
            </para>
            <example>
                <title>Extending Actions: XML</title>
                <programlisting language="xml">
<xi:include href="samples/apix-action.xml" parse="text"/>
                </programlisting>
            </example>
            <para>
                In JSON, the action name is the extension alias followed by a colon ":" followed by a unique identification of the action.
            </para>
            <example>
                <title>Extending Actions: JSON</title>
                <programlisting language="javascript">
<xi:include href="samples/apix-action.json" parse="text"/>
                </programlisting>
            </example>
        </section>
        <section>
            <title>Extending Headers and States</title>
            <para>
                To extend a header, name it <code>X-</code> followed by the extension alias followed by a unique identification of the header:
                <itemizedlist spacing="compact">
                    <listitem>
                        <para><code>X-RAX-CBS-Header1</code>: Value</para>
                    </listitem>
                    <listitem>
                        <para><code>X-RAX-CBS-Header2</code>: Value</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                To extend a state, name it with the extension alias followed by a colon ":" followed by a unique identification of the state:
            </para>
            <example>
                <title>Extending Headers and States: XML</title>
                <programlisting language="xml">
<xi:include href="samples/apix-header.xml" parse="text"/>
                </programlisting>
            </example>
            <example>
                <title>Extending Headers and States: JSON</title>
                <programlisting language="javascript">
<xi:include href="samples/apix-header.json" parse="text"/>
                </programlisting>
            </example>
        </section>
        <section>
            <title>Extending Resources</title>
            <para>
               All major resources can reference an extension via <code>/ext</code>. 
            </para>
            <para> Extensions are always defined at
                    <parameter>/path/to/resource</parameter><code>/ext/</code><parameter>ext-alias/newResource</parameter>. </para>
        </section>
        <section>
            <title>Extending Parameters</title>
            <para>
                To extend a parameter, append the name of the relevant extension and the name of that extension's parameter.
                For example, a &GET; against
                https://api.servers.rackspacecloud.com/v1.0/224532/servers?RAX-PIE:test=1244
                sets the <code>RAX-PIE</code> extension's <code>test</code> parameter to the value of 1244.
            </para>
        </section>
    </chapter>
    <chapter>
        <title>API Extensions and API Features</title>
        <section>
            <title>Specification Governance</title>
            <para> OpenStack's existing structure adequately addresses governance of API extensions
                and features. For each service, the service's he Architecture Review Board for
                OpenStack API extensions. </para>
        </section>
        <section>
            <title>Promotion Path</title>
            <para> 
                The simplest promotion path for an extension is from a single vendor to OpenStack
                approval to implementation as a core API feature. 
            </para>
            <para>
                Some extensions may be developed cooperatively by more than one vendor; 
                these are known as Multi-Vendor extensions and are identified by the <code>MLTI</code> prefix.
                Alternatively, an extension may begin with a single vendor but become a Mult-Vendor extension at some point in its life. 
                In either of these cases, the extension follows same promotion path from Multi-Vendor status to OpenStack approval to implementation as a core API feature.
            </para>
            <para>
                This multi-step promotion path allows competing extensions to coexist and makes it possible to experiment with new features before deciding whether to incorporate them into the API standard.
                It also means that API specifications are written bottom-up rather than top-down, so that implementations determine new features and the API is not designed in a vacuum. 
            </para>
            <figure xml:id="promotion">
                <title>An API extension can become a core feature of the API if approved by OpenStack.</title>
                <mediaobject>
                    <imageobject>
                        <imagedata scale="90" fileref="figures/apix-promotion.svg" format="SVG" align="center"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <para>
                Some extensions should never be promoted to core features.
                This can be because the extension implements niche functionality that doesn't make sense in the core API,
                or because it implements functionality that can't be used within the core API since it would prevent a particular backend from implementing the full set of core features.
            </para>
            <para>
                For example, the ability to dynamically change the port number for a load balancer might be useful as an extension but problematic in the core API.
                If most but not all load balancers could support this feature, the extension must not be promoted into the core API.
                Instead, providing the feature via an API extension makes it available to customers who would like to use it but prevents it from creating problems for those who cannot use it.
            </para>
        </section>
    </chapter>
    <chapter>
        <title>Challenges</title>
        <para>
            While API extensions can solve some problems relating to the need for simultaneous standardization and flexibility, they can create a new set of challenges. 
            Two problematic areas are language bindings and JSON collections. 
        </para>
        <section>
            <title>Language Bindings</title>
            <para>
                API extensions should be supported at the language binding layer. 
                A simple approach may be to allow the language bindings themselves to be extensible, so that extensions may be simply added to an existing binding.
            </para>
        </section>
        <section>
            <title>JSON and Collections</title>
            <para>
                How can attributes be added to extend a collection of public addresses?
            </para>
            <example>
                <title>Question: Extending a Collection</title>
                <programlisting language="javascript">
<xi:include href="samples/apix-address-q.json" parse="text"/>
                </programlisting>
            </example>
            <para>
                Wrap the array into an object.
            </para>
            <example>
                <title>Answer: Array as Object</title>
                <programlisting language="javascript">
<xi:include href="samples/apix-address-a.json" parse="text"/>
                </programlisting>
            </example>
            <para>
                How can a collection be identified?
            </para>
        <example>
            <title>Question: Naming a Collection</title>
            <programlisting language="javascript">
<xi:include href="samples/apix-collection-q.json" parse="text"/>
                </programlisting>
        </example>
        <para>
            Name the collection as the plural form of the items it contains. If the collection contains servers, name it <code>servers</code>.
        </para>
        <example>
            <title>Answer: Pluralize</title>
            <programlisting language="javascript">
<xi:include href="samples/apix-collection-a.json" parse="text"/>
                </programlisting>
        </example>
        <para>
            A better approach is to have a single name for the array:
            <itemizedlist spacing="compact">
                <listitem>
                    <para>This is more generalizable; it always works.</para>
                </listitem>
                <listitem>
                    <para>This limits the introduction of entities not found in other representations.</para>
                </listitem>
                <listitem>
                    <para>This creates a common pattern for collections.</para>
                </listitem>
            </itemizedlist>
        </para>
            <example>
                <title>Array with Single Name</title>
                <programlisting language="javascript">
<xi:include href="samples/apix-name-array.json" parse="text"/>
                </programlisting>
            </example>
            <para>Other approaches range from using generalizable values to ad hoc. Each approach
                has its advantages and disadvantages. It may be that there is no approach that is
                truly JSONic when dealing with collections. The goal is to provide extensibility in
                JSON but avoid BadgerFish. Using alias prefixes moves toward this goal. </para>
            <example>
                <title>Extensibility within a Collection</title>
                <programlisting language="javascript">
<xi:include href="samples/apix-name-extensibility.json" parse="text"/>
                </programlisting>
            </example>   
        </section>
    </chapter>
    <chapter>
        <title>Summary</title>
        <section>
            <title>Benefits of Extensions</title>
            <para>
                API extensions provide several key benefits:
                <itemizedlist spacing="compact">
                    <listitem>
                        <para>a stable core API with support for innovation</para>
                    </listitem>
                    <listitem>
                        <para>a method of adding new features quickly and in a backward-compatible manner</para>
                    </listitem>
                    <listitem>
                        <para>a method of supporting the capabilities of different backends</para>
                    </listitem>
                    <listitem>
                        <para>a method of ensuring compatibility between different kinds of OpenStack deployments</para>
                    </listitem>
                    <listitem>
                        <para>a method of allowing vendors to differentiate their products with niche features</para>
                    </listitem>
                    <listitem>
                        <para>a method of testing new features before they become part of the core API</para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>
        <section>
            <title>Ways to Use Extensions</title>
            <para>
                API extensions are queryable. 
            </para>  
            <para>
                To discover which extensions are available, issue a &GET; to <code>/extensions</code>.
            </para>
            <para>
                To use a specific extension, issue a &GET; to <code>/extensions/</code><parameter>{EXT-ALIAS}</parameter>.
            </para>
            <para>
                To prevent conflicts between extensions, use aliases and namespaces to identify each extension's vendor.
            </para>
            <para>
                To move an extension into the core API, work within OpenStack to have it promoted.
            </para>
        </section>
    </chapter>
</book>