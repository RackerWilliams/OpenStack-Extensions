<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book [
        <!-- Some useful entities borrowed from HTML -->
        <!ENTITY ndash  "&#x2013;">
        <!ENTITY mdash  "&#x2014;">
        <!ENTITY hellip "&#x2026;">

        <!-- Useful for describing APIs -->
        <!ENTITY GET    '<command xmlns="http://docbook.org/ns/docbook">GET</command>'>
        <!ENTITY PUT    '<command xmlns="http://docbook.org/ns/docbook">PUT</command>'>
        <!ENTITY POST   '<command xmlns="http://docbook.org/ns/docbook">POST</command>'>
        <!ENTITY DELETE '<command xmlns="http://docbook.org/ns/docbook">DELETE</command>'>

        <!ENTITY CHECK  '<inlinemediaobject xmlns="http://docbook.org/ns/docbook">
                 <imageobject>
                  <imagedata fileref="img/Check_mark_23x20_02.svg"
                             format="SVG" scale="60"/>
                </imageobject>
              </inlinemediaobject>'>

        <!ENTITY ARROW  '<inlinemediaobject xmlns="http://docbook.org/ns/docbook">
                 <imageobject>
                  <imagedata fileref="img/Arrow_east.svg"
                             format="SVG" scale="60"/>
                </imageobject>
              </inlinemediaobject>'>
]>
<book xmlns="http://docbook.org/ns/docbook"
      xmlns:xlink="http://www.w3.org/1999/xlink"
      xmlns:xi="http://www.w3.org/2001/XInclude"
      xmlns:svg="http://www.w3.org/2000/svg"
      xmlns:m="http://www.w3.org/1998/Math/MathML"
      xmlns:html="http://www.w3.org/1999/xhtml"
      xmlns:db="http://docbook.org/ns/docbook"
      version="5.0" status="draft">
    <title>OpenStack API Extensions</title>
    <subtitle>An Overveiw</subtitle>
    <info>
        <copyright>
            <year>2010</year>
            <year>2011</year>
            <holder>Rackspace US, Inc.</holder>
        </copyright>
        <pubdate>2011-05-13</pubdate>
        <legalnotice role="apache2">
            <annotation>
                <remark>Copyright details are filled in by the template.</remark>
            </annotation>
        </legalnotice>
        <abstract>
            <para>
                This document provides an overview of the OpenStack API extension
                mechanism.
            </para>
        </abstract>
    </info>
    <chapter>
        <title>Overview</title>
        <para>
            The OpenStack extension mechanism makes it possible to add
            functionality to OpenStack APIs in a manner that ensures
            compatibility with existing clients. This capability
            allows OpenStack operators and vendors to distinguish
            themselves by providing niche functionality to their
            clients. It also provides a means by which new features
            may be proposed for consideration in upcoming versions of
            core APIs.
        </para>
        <para>
            This document describes the extension mechanism in detail.
            It provides guidance to API implementors and clients on
            developing and consuming API extensions and it describes
            the rules by which extensions are governed. Finally, it
            describes the process used to promote API extensions to
            new features in core OpenStack APIs.
        </para>
        <section>
            <title>Document Change History</title>
            <informaltable rules='all'>
                <thead>
                        <tr>
                            <td align="center" colspan="1">Revision Date</td>
                            <td align="center" colspan="4">Summary of Changes</td>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td colspan="1" align="center">May 13, 2011</td>
                            <td colspan="4">
                                <itemizedlist spacing="compact">
                                    <listitem>
                                        <para> Initial draft. </para>
                                    </listitem>
                                </itemizedlist>
                            </td>
                        </tr>
                    </tbody>
            </informaltable>
        </section>
    </chapter>
    <chapter>
        <title>Background</title>
            <para>
                In the 1990s, OpenGL was developed as a portable open
                graphics library standard.  The goal was to provide a
                cross-platform library that could enable developers to
                produce 3D graphics in real time (30-120 frames per
                second).  There were several major challenges in
                meeting this goal: In order to be considered an open
                standard, control needed to shift from Silicon
                Graphics (SGI), who originally developed OpenGL, to an
                independent Architecture Review Board (ARB) who would
                be responsible for approving specification changes,
                marking new releases, and ensuring conformance
                testing.  Additionally, the graphics library itself
                would need to be designed in a manner that would allow
                the establishment of a stable and portable platform
                for developers.  Finally, the library would need to
                garner the support of graphics hardware vendors as
                they would be providing the hardware acceleration
                needed to meet the goal of performing at real-time
                speeds.
            </para>
            <para>
                Gaining vendor support is challenging because vendors
                are often in direct competition with one another.
                They differentiate themselves by creating innovative
                new features and by providing niche functionality to
                their users.  Thus, OpenGL was faced with two
                competing requirements: On the one hand, it needed to
                abstract away vendor differences in order to provide a
                stable cross platform environment to developers. On
                the other hand, in order to garner vendor support, it
                needed a method by which vendors could differentiate
                themselves and provide innovative new features and
                niche functionality to their users.
            </para>
            <para>
                The solution was the OpenGL extension mechanism. The
                extension mechanism achieved balance between the two
                requirements by allowing vendors to define extensions
                to the core OpenGL specification while maintaining the
                core specification under the direction of the
                Architecture Review Board. The core specification
                remained uncluttered and presented a unified view of
                common functionality between vendors. Because
                extensions were detectable at run time, developers
                could write portable applications that could adapt to
                the hardware in which they were running. This method
                of allowing for an extensible API has proven to be a
                very successful strategy.  More than 500 extensions
                have been defined in OpenGL's lifetime and many
                vendors including NVidia, ATI, Apple, IBM, and Intel
                have participated in the process by developing their
                own custom extensions. Additionally, many key
                innovations (such as vertex and fragment shaders) have
                been developed via the extension process and are now
                part of the core OpenGL API.
            </para>
            <para>
                OpenStack, while very different than OpenGL, shares
                many similar goals and faces many of the same
                challenges.  OpenStack APIs are designed to be open
                API standards.  An important goal is to provide
                developers with a ubiquitous, stable, any-scale cloud
                development platform that abstracts away many of the
                differences between hosting providers and their
                underlying infrastructure (hypervisors, load
                balancers, etc.).  A Policy Review Board, similar to
                OpenGL's Architecture Review Board, is responsible to
                direct development of these APIs in a manner that
                ensures these goals are met. As with OpenGL, OpenStack
                requires support from vendors (and cloud providers) in
                order to be successful. As a result, OpenStack APIs
                also aim to provide vendors with a platform which
                allows them to differentiate themselves by providing
                innovating new features and niche functionality to
                their users.  Because of these similarities, the
                OpenStack extension mechanism described in this
                document is modeled after the OpenGL extension
                mechanism.  The methods by which extensions are
                defined vary drastically of course since the nature of
                the APIs is very different (C vs REST), however, the
                manner in which extensions are documented, the way in
                which vendors are attributed, and the promotion path
                that an extension follows, all borrow heavily from
                OpenGL.
            </para>
            <section>
            <title>Defining Extensions</title>
            <para>
                Extensions add capability to an API beyond those defined in the API's specification.
            </para>
            <para> An API specification must be written to allow for extensibility. Flexibility in
                the specification contract allows for new data elements, actions, states, headers,
                parameters, and resource types. The core API specification defines the extension
                mechanism; however, extensions themselves are not part of the core. </para>
            <para> Implementors are only required to implement the core API. They must implement the
                core API completely so clients can rely upon a minimal level of functionality. </para>
            <para>
                Extensions can follow a promotion path, at the end of which an extension may become part of a future version of the core API.
                While promotion is possible, it is not inevitable: niche extensions are unlikely to be promoted to the core.
            </para>
        </section>
        <section>
            <title>Extensions versus Versions</title>
            <para> With API extensions in place, API implementations can differ from each other in
                terms of both their versions and their extensions. Extensions can apply to a variety
                of backends, such as many hypervisors and many load balancers. Accurately describing
                an API implementation requires awareness of its versions and extensions as sources
                of variation. </para>
            <table frame="all">
                <title>Versions and Extensions Differ in Specific Ways</title>
                <tgroup cols="2">
                    <colspec colname="c1" colnum="1" colwidth="1.0*"/>
                    <colspec colname="c2" colnum="2" colwidth="1.0*"/>
                    <thead>
                        <row>
                            <entry>Versions</entry>
                            <entry>Extensions</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>
                                <para><emphasis role="bold">Centralized:</emphasis> Versions are
                                    maintained by the entity that controls the API Spec: the
                                    OpenStack Architecture Review Board. Only the ARB can create a
                                    new version; only the ARB defines what "OpenStack Compute 1.1"
                                    means.</para>
                            </entry>
                            <entry>
                                <para><emphasis role="bold">Decentralized:</emphasis> Extensions are
                                    maintained by third parties, including  individual OpenStack
                                    developers and corporate software vendors. Anyone can create an
                                    extension.</para>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <para><emphasis role="bold">Core:</emphasis> Versions support core
                                    functionality.</para>
                            </entry>
                            <entry>
                                <para><emphasis role="bold">Niche:</emphasis> Extensions provide
                                    specialized functionality.</para>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <para><emphasis role="bold">Rare:</emphasis> Versions provide a
                                    stable platform on which to develop.</para>
                            </entry>
                            <entry>
                                <para><emphasis role="bold">Frequent:</emphasis> Extensions bring
                                    new features to the market quickly and in a compatible
                                    manner.</para>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <para><emphasis role="bold">Queryable: </emphasis> Issuing a &GET;
                                    on the base URL (<code>/</code>) of the API endpoint returns
                                    information about what versions are available.</para>
                            </entry>
                            <entry>
                                <para><emphasis role="bold">Queryable:</emphasis> Issuing a &GET; on
                                    the API's extensions resource (<code>/v1.1/extensions</code>)
                                    returns information about what extensions are available.</para>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>

        </section>
        <section>
            <title>Extensions and Pluggability</title>
            <para> Each driver may expose functionality that a client may access via an extension.
                In the example illustrated below, the load balancing service API's core and
                extensions both provide functionality enabling the service to interact with its Zeus
                backend. </para>
            <figure xml:id="core-extensions">
                <title>One backend can be reached by both the core API and API extensions.</title>
                <mediaobject>
                    <imageobject>
                        <imagedata scale="100" fileref="figures/apix-1service-core-extensions-manybackends.svg" format="SVG" align="center"/>
                    </imageobject>
                </mediaobject>
            </figure>
        </section>
    </chapter>
    <chapter>
        <title>API Extensions and ReST</title>
              <para>
                Extensions can define:
                <itemizedlist spacing="compact">
                    <listitem>
                        <para>new elements</para>
                    </listitem>
                    <listitem>
                        <para>new attributes of existing elements</para>
                    </listitem>
                    <listitem>
                        <para>new data</para>
                    </listitem>
                    <listitem>
                        <para>new headers</para>
                    </listitem>
                    <listitem>
                        <para>new states</para>
                    </listitem>
                    <listitem>
                        <para>new resources</para>
                    </listitem>
                    <listitem>
                        <para>new parameters</para>
                    </listitem>
                    <listitem>
                        <para>new MIME types</para>
                    </listitem>
                    <listitem>
                        <para>new capabilities</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                New MIME types can provide support for Atom or plist representation.
            </para>
            <para>
                New capabilities can include the ability to edit an otherwise-uneditable attribute.
            </para>       
            <section>
                <title>Identifying Available Extensions</title>
            <para>
                Extensions are queryable. 
                For any service API, making a single call to <code>/extensions</code> returns information about what extensions are available and how to learn more about them. 
            </para>
            <para> Query <code>/extensions</code> to obtain basic information about an API's
                extensions, including their human-readable names and descriptions, links to
                documentation, and identification of each extension's alias, namespace, and vendor.
                In the example below, the query returns information about two available extensions
                to the API: <code>RAX-PIE</code> and <code>RAX-CBS</code>.</para>
            <example>
                <title>Extension Query: XML</title>
                <?dbfo keep-together="auto"?>
                <programlistingco>
                    <areaspec>
                        <area xml:id="query.human-readable.name" units="linecolumn" coords="5 1"/>
                        <area xml:id="query.human-readable.description" units="linecolumn" coords="14 1"/>
                        <area xml:id="query.docs" units="linecolumn" coords="11 1"/>
                        <area xml:id="query.identifiers" units="linecolumn" coords="7 1"/>
                        <area xml:id="query.vendor.namespace" units="linecolumn" coords="18 1"/>
                        <area xml:id="query.vendor.alias" units="linecolumn" coords="19 1"/>
                    </areaspec>
                    <programlisting language="xml">
<xi:include href="samples/apix-query.xml" parse="text"/>
                    </programlisting>
                </programlistingco>
            </example>
                <calloutlist>
                    <callout arearefs="query.human-readable.name">
                        <para>
                            The query returns the extension's human-readable name.
                        </para>
                    </callout>
                    <callout arearefs="query.human-readable.description">
                        <para>
                            The query returns the extension's human-readable description.
                        </para>
                    </callout>
                    <callout arearefs="query.docs">
                        <para>
                            The query returns links to documentation in multiple formats.
                        </para>
                    </callout>
                    <callout arearefs="query.identifiers">
                        <para>
                            The query uniquely identifies the extension as an alias within a namespace.
                        </para>
                    </callout>
                    <callout arearefs="query.vendor.namespace">
                        <para>
                            The query identifies the extension's vendor in the extension's namespace.
                        </para>
                    </callout>
                    <callout arearefs="query.vendor.alias">
                        <para>
                            The query identifies the extension's vendor in the extension's alias.
                        </para>
                    </callout>
                </calloutlist>
        </section>
        <section>
            <title>Identifying an Extension's Vendor</title>
            <para>
                An extension alias always contains a prefix that identifies the vendor. 
            </para>
            <table frame="all">
                <title>Extension Alias Identifies Vendor</title>
                <tgroup cols="2">
                    <colspec colname="c2" colnum="1" colwidth="1.0*"/>
                    <colspec colname="newCol3" colnum="2" colwidth="8.66*"/>
                    <thead>
                        <row>
                            <entry>Vendor</entry>
                            <entry>Prefix</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>Citrix</entry>
                            <entry>
                                <para>
                                    <code>CTX</code>
                                </para>
                            </entry>
                        </row>
                        <row>
                            <entry>Multi-Vendor</entry>
                            <entry>
                                <code>MLTI</code>
                            </entry>
                        </row>
                        <row>
                            <entry>NASA</entry>
                            <entry>
                                <code>NASA</code></entry>
                        </row>
                        <row>
                            <entry>OpenStack</entry>
                            <entry>
                                <para>
                                    <code>OS</code>... </para>
                            </entry>
                        </row>
                        <row>
                            <entry>Rackspace</entry>
                            <entry>
                                <code>RAX</code>... </entry>
                        </row>
                        <row>
                            <entry>...</entry>
                            <entry> ...</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <para>
                In this example, the <code>RAX</code> prefix in the extension's alias identifies the extension's vendor as Rackspace:
            </para>
            <example>
                <title>Vendor ID in Alias Extension: XML</title>
                <programlisting language="xml">
                <?dbfo keep-together="always"?>
<xi:include href="samples/apix-vendor.xml" parse="text"/>
                </programlisting>
            </example>
            <para>
                Each extension is associated with a namespace; because the namespace is named to identify a vendor, the extension's association with a namespace also identifies the extensions's vendor.
            </para>
            <table frame="all">
                <title>Namespace Identifies Vendor</title>
                <tgroup cols="2">
                    <colspec colname="c2" colnum="1" colwidth="1.0*"/>
                    <colspec colname="newCol3" colnum="2" colwidth="8.69*"/>
                    <thead>
                        <row>
                            <entry>Vendor</entry>
                            <entry>Namespace</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>Citrix</entry>
                            <entry>
                                <para>
                                    <code>http://docs.citrix.com</code>... </para>
                            </entry>
                        </row>
                        <row>
                            <entry>NASA</entry>
                            <entry>
                                <code>http://docs.nasa.org</code>... </entry>
                        </row>
                        <row>
                            <entry>OpenStack</entry>
                            <entry>
                                <para>
                                    <code>http://docs.openstack.com/ext/OS/</code>... </para>
                            </entry>
                        </row>
                        <row>
                            <entry>Rackspace</entry>
                            <entry>
                                <code>docs.rackspacecloud.com</code>... </entry>
                        </row>
                        <row>
                            <entry>...</entry>
                            <entry>...</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <para>
                Providing two ways of identifying each extension's vendor improves the likelihood that multiple extensions can coexist without creating conflicts.
                For this purpose, a namespace such as <code>http://docs.rackspacecloud.com/servers/api/ext/pie/v1.0</code> is most useful to XML media types; 
                an alias such as <code>RAX-PIE</code> is most useful to non-XML media types such as JSON, as well as in headers and parameters.
                Because extensions are likely to be implemented by middleware, conflicts are possible without a standardized approach to identifying each extension and its vendor.
            </para>
            <figure xml:id="shared">
                <title>Two extensions add a "shared" attribute; one overrides the other.</title>
                <mediaobject>
                    <imageobject>
                        <imagedata scale="100" fileref="figures/apix-2extensions-shared.svg" format="SVG" align="center"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <figure xml:id="filter">
                <title>Two extensions read a "filter" parameter; both are activated.</title>
                <mediaobject>
                    <imageobject>
                        <imagedata scale="100" fileref="figures/apix-2extensions-filter.svg" format="SVG" align="center"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <para>
                OpenStack should maintain a registry associating extension vendors with prefixes and namespaces. 
                Anyone should be able to register this identifying information for a vendor.
                The registration process should not require approval or coordination.
            </para>
        </section>
        <section>
            <title>Extending Data</title>
            <para>
                Extensions can be used to add data.
            </para>
            <para>
                In XML, attributes may be added to elements if they are in the extension namespace. 
                After the final element, elements can be added if "Unique Particle Attribution" is not violated.
            </para>
            <example>
                <title>Extending Data: XML</title>
                <?dbfo keep-together="always"?>
                <programlisting language="xml">
<xi:include href="samples/apix-data.xml" parse="text"/>
                </programlisting>
            </example>
            <para> In JSON, the action name is the alias followed by a colon. </para>
            <example>
                <title>Extending Data: JSON</title>
                <?dbfo keep-together="always"?>
                <programlisting language="javascript">    
<xi:include href="samples/apix-data.json" parse="text"/>
                </programlisting>
            </example>
        </section>
        <section>
            <title>Extending Actions</title>
            <para>
                In XML, actions are defined by the extension namespace.
            </para>
            <example>
                <title>Extending Actions: XML</title>
                <programlisting language="xml">
                <?dbfo keep-together="always"?>    
<xi:include href="samples/apix-action.xml" parse="text"/>
                </programlisting>
            </example>
            <para> In JSON, the action name is the extension alias followed by a colon followed by a
                unique identification of the action. </para>
            <example>
                <title>Extending Actions: JSON</title>
                <?dbfo keep-together="always"?>
                <programlisting language="javascript">
<xi:include href="samples/apix-action.json" parse="text"/>
                </programlisting>
            </example>
        </section>
        <section>
            <title>Extending Headers and States</title>
            <para>
                To extend a header, name it <code>X-</code> followed by the extension alias followed by a unique identification of the header.
                In the example below, <code>X-Auth-User</code> and <code>X-Auth-Key</code> relate to the core API; 
                <code>X-RAX-CBS-Header1</code> and <code>X-RAX-CBS-Header2</code> relate to the API's RAX-CBS extension.
            </para>
            <example>
                <title>Authentication Request with Extended X-Headers</title>
                <?dbfo keep-together="always"?>
                <literallayout class="monospaced">
GET /v1.0 HTTP/1.1
Host: auth.api.openstack.com
X-Auth-User: jdoe
X-Auth-Key: a86850deb2742ec3cb41518e26aa2d89
X-RAX-CBS-Header1: value1
X-RAX-CBS-Header2: value2
                </literallayout>
            </example>
            <para> To extend a state, name it with the extension alias followed by a colon followed
                by a unique identification of the state. </para>
            <example>
                <title>Extending Headers and States: XML</title>
                <programlisting language="xml">
                <?dbfo keep-together="always"?>    
<xi:include href="samples/apix-header.xml" parse="text"/>
                </programlisting>
            </example>
            <example>
                <title>Extending Headers and States: JSON</title>
                <programlisting language="javascript">
                <?dbfo keep-together="always"?>
<xi:include href="samples/apix-header.json" parse="text"/>
                </programlisting>
            </example>
        </section>
        <section>
            <title>Extending Resources</title>
            <para>
               All major resources can reference an extension via <code>/ext</code>. 
            </para>
            <para> Extensions are always defined at
                    <parameter>/path/to/resource</parameter><code>/ext/</code><parameter>ext-alias/newResource</parameter>. </para>
        </section>
        <section>
            <title>Extending Parameters</title>
            <para> To extend a parameter, append the alias of the relevant extension followed by a
                colon followed by the name of that extension's parameter. For example, a &GET;
                against https://api.servers.rackspacecloud.com/v1.0/224532/servers?RAX-PIE:test=1244
                sets the <code>RAX-PIE</code> extension's <code>test</code> parameter to the value
                of 1244. </para>
        </section>
    </chapter>
    <chapter>
        <title>API Extensions and API Features</title>
        <section>
            <title>Specification Governance</title>
            <para> OpenStack's existing structure adequately addresses governance of API extensions
                and features. For each service, the team lead handles concerns about functionality
                and the service's Architecture Review Board approves changes and resolves conflicts;
                the OpenStack Governance board provides oversight to maintain consistency and
                prevent conflicts among services.</para>
            <para>
                When OpenStack approves an extension, the extension's prefix is changed so that rather than identifying a specific vendor it identifies OpenStack as its source.
                For example, if the <code>RAX-PIE</code> extension were to be approved by OpenStack, the approved version would be known as <code>OS-PIE</code>.
                While the <code>OS-</code> prefix indicates approval by OpenStack,
                such approval does not necessarily imply that the extension is being considered for inclusion in a future revision of the API's core specification.
                A niche extension that offers highly useful functionality can gain OpenStack approval.
                Such an extension may never become a feature of the core API, but the extension can become one that is so frequently implemented that clients can rely on it in most cases.
            </para>
        </section>
        <section>
            <title>Promotion Path</title>
            <para> 
                The simplest promotion path for an extension is from a single vendor to OpenStack
                approval to implementation as a core API feature. 
            </para>
            <para> Some extensions may be developed cooperatively by more than one vendor; these are
                known as Multi-Vendor extensions and are identified by the <code>MLTI</code> prefix.
                Alternatively, an extension may begin with a single vendor but become a Multi-Vendor
                extension at some point in its life. In either of these cases, the extension follows
                same promotion path from Multi-Vendor status to OpenStack approval to implementation
                as a core API feature. </para>
            <para>
                This multi-step promotion path allows competing extensions to coexist and makes it possible to experiment with new features before deciding whether to incorporate them into the API standard.
                It also means that API specifications are written bottom-up rather than top-down, so that implementations determine new features and the API is not designed in a vacuum. 
            </para>
            <figure xml:id="promotion">
                <title>An API extension can become a core feature of the API if approved by OpenStack.</title>
                <mediaobject>
                    <imageobject>
                        <imagedata scale="80" fileref="figures/apix-promotion.svg" format="SVG" align="center"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <para>
                Some extensions should never be promoted to core features.
                This can be because the extension implements niche functionality that doesn't make sense in the core API,
                or because it implements functionality that can't be used within the core API since it would prevent a particular backend from implementing the full set of core features.
            </para>
            <para>
                For example, the ability to dynamically change the port number for a load balancer might be useful as an extension but problematic in the core API.
                If most but not all load balancers could support this feature, the extension must not be promoted into the core API.
                Instead, providing the feature via an API extension makes it available to customers who would like to use it but prevents it from creating problems for those who cannot use it.
            </para>
        </section>
    </chapter>
    <chapter>
        <title>Challenges</title>
        <para>
            While API extensions can solve some problems relating to the need for simultaneous standardization and flexibility, they can create a new set of challenges. 
            Two problematic areas are language bindings and JSON collections. 
        </para>
        <section>
            <title>Language Bindings</title>
            <para>
                API extensions should be supported at the language binding layer. 
                A simple approach may be to allow the language bindings themselves to be extensible, so that extensions may be simply added to an existing binding.
            </para>
        </section>
        <section>
            <title>JSON and Collections</title>
            <para>
                How can attributes be added to extend a collection of public addresses?
            </para>
            <example>
                <title>Question: Extending a Collection</title>
                <?dbfo keep-together="always"?>
                <programlisting language="javascript">
<xi:include href="samples/apix-address-q.json" parse="text"/>
                </programlisting>
            </example>
            <para>
                Wrap the array into an object.
            </para>
            <example>
                <title>Answer: Array as Object</title>
                <?dbfo keep-together="always"?>
                <programlisting language="javascript">
<xi:include href="samples/apix-address-a.json" parse="text"/>
                </programlisting>
            </example>
            <para>
                How can a collection be identified?
            </para>
        <example>
            <title>Question: Naming a Collection</title>
            <?dbfo keep-together="always"?>
            <programlisting language="javascript">
<xi:include href="samples/apix-collection-q.json" parse="text"/>
                </programlisting>
        </example>
        <para>
            Name the collection as the plural form of the items it contains. If the collection contains servers, name it <code>servers</code>.
        </para>
        <example>
            <title>Answer: Pluralize</title>
            <?dbfo keep-together="always"?>
            <programlisting language="javascript">
<xi:include href="samples/apix-collection-a.json" parse="text"/>
                </programlisting>
        </example>
        <para>
            A better approach is to have a single name for the array:
            <itemizedlist spacing="compact">
                <listitem>
                    <para>This is more generalizable; it always works.</para>
                </listitem>
                <listitem>
                    <para>This limits the introduction of entities not found in other representations.</para>
                </listitem>
                <listitem>
                    <para>This creates a common pattern for collections.</para>
                </listitem>
            </itemizedlist>
        </para>
            <example>
                <title>Array with Single Name</title>
                <?dbfo keep-together="always"?>
                <programlisting language="javascript">
<xi:include href="samples/apix-name-array.json" parse="text"/>
                </programlisting>
            </example>
            <para>Other approaches range from using generalizable values to ad hoc. Each approach
                has its advantages and disadvantages. It may be that there is no approach that is
                truly JSONic when dealing with collections. The goal is to provide extensibility in
                JSON without requiring a tool such as BadgerFish, generating JSON from XML. Using alias prefixes moves toward this goal. </para>
            <example>
                <title>Extensibility within a Collection</title>
                <?dbfo keep-together="always"?>
                <programlisting language="javascript">
<xi:include href="samples/apix-name-extensibility.json" parse="text"/>
                </programlisting>
            </example>   
        </section>
    </chapter>
    <chapter>
        <title>Summary</title>
        <section>
            <title>Benefits of Extensions</title>
            <para>
                API extensions provide several key benefits:
                <itemizedlist spacing="compact">
                    <listitem>
                        <para>a stable core API with support for innovation</para>
                    </listitem>
                    <listitem>
                        <para>a method of adding new features quickly and in a backward-compatible manner</para>
                    </listitem>
                    <listitem>
                        <para>a method of supporting the capabilities of different backends</para>
                    </listitem>
                    <listitem>
                        <para>a method of ensuring compatibility between different kinds of OpenStack deployments</para>
                    </listitem>
                    <listitem>
                        <para>a method of allowing vendors to differentiate their products with niche features</para>
                    </listitem>
                    <listitem>
                        <para>a method of testing new features before they become part of the core API</para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>
        <section>
            <title>Ways to Use Extensions</title>
            <para>
                API extensions are queryable. 
            </para>  
            <para>
                To discover which extensions are available, issue a &GET; to <code>/extensions</code>.
            </para>
            <para>
                To use a specific extension, issue a &GET; to <code>/extensions/</code><parameter>{EXT-ALIAS}</parameter>.
            </para>
            <para>
                To prevent conflicts between extensions, use aliases and namespaces to identify each extension's vendor.
            </para>
            <para>
                To move an extension into the core API, work within OpenStack to have it promoted.
            </para>
        </section>
    </chapter>
</book>
